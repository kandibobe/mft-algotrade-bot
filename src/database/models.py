"""
Database Models
===============

SQLAlchemy models for persisting trading state.
"""

from datetime import datetime

from sqlalchemy import JSON, Column, DateTime, Float, ForeignKey, Integer, String
from sqlalchemy.orm import relationship

from .db_manager import Base


class SignalRecord(Base):
    """
    Why we traded: The logic state at decision time.
    Generated by the Strategy Logic before any order is placed.
    """

    __tablename__ = "signals"

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    symbol = Column(String(20), nullable=False)
    strategy_name = Column(String(100))
    signal_type = Column(String(20))  # 'buy', 'sell', 'hold' (if we log rejections)

    # Context
    regime = Column(String(50))
    model_confidence = Column(Float)

    # Primary indicators (snapshot)
    rsi = Column(Float)
    ema_200 = Column(Float)
    close_price = Column(Float)

    # Link to resulting trade (if any)
    trade_id = Column(Integer, ForeignKey("trades.id"), nullable=True)

    meta_data = Column(JSON)  # Any extra context


class ExecutionRecord(Base):
    """
    How we traded: Execution quality metrics.
    Generated by the Order Executor upon fill.
    """

    __tablename__ = "executions"

    id = Column(Integer, primary_key=True)
    trade_id = Column(Integer, ForeignKey("trades.id"), nullable=False)

    timestamp = Column(DateTime, default=datetime.utcnow)
    symbol = Column(String(20))
    side = Column(String(10))

    # Prices
    target_price = Column(Float)  # The price we wanted (Decision Price)
    fill_price = Column(Float)  # The price we got

    # Quality Metrics
    slippage_pct = Column(Float)
    latency_ms = Column(Float)  # Time from Signal to Fill
    spread_at_fill = Column(Float)  # Market spread at moment of fill

    meta_data = Column(JSON)


class TradeRecord(Base):
    """Persisted trade record (Accounting View)."""

    __tablename__ = "trades"

    id = Column(Integer, primary_key=True)
    symbol = Column(String(20), nullable=False)
    exchange = Column(String(50))
    side = Column(String(10))
    entry_price = Column(Float)
    exit_price = Column(Float)
    amount = Column(Float)
    pnl_usd = Column(Float)
    pnl_pct = Column(Float)
    entry_time = Column(DateTime, default=datetime.utcnow)
    exit_time = Column(DateTime)
    strategy_name = Column(String(100))
    regime_at_entry = Column(String(50))
    meta_data = Column(JSON)

    # Relationships
    signal = relationship("SignalRecord", backref="trade", uselist=False)
    execution = relationship("ExecutionRecord", backref="trade", uselist=False)


class SystemEvent(Base):
    """Log of critical system events (restarts, errors, circuit breaker trips)."""

    __tablename__ = "system_events"

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    event_type = Column(String(50))
    component = Column(String(50))
    message = Column(String(500))
    details = Column(JSON)


class ShadowTradeRecord(Base):
    """
    Record of a "Shadow" trade (Paper Trading 2.0).
    Used to validate execution quality without risking real funds.
    """

    __tablename__ = "shadow_trades"

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    symbol = Column(String(20), nullable=False)
    side = Column(String(10))
    
    # Latency Metrics
    signal_timestamp = Column(DateTime)
    submission_timestamp = Column(DateTime)
    fill_timestamp = Column(DateTime)
    latency_ms = Column(Float)

    # Decision Context
    target_price = Column(Float)
    fill_price = Column(Float)
    amount = Column(Float)
    
    # Quality Metrics
    slippage_pct = Column(Float)
    expected_pnl_usd = Column(Float)
    
    strategy_name = Column(String(100))
    meta_data = Column(JSON)
