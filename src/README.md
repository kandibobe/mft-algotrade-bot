# Stoic Citadel - Shared Library

**Version**: 1.0.0
**Purpose**: –û–±–µ—Å–ø–µ—á–µ–Ω–∏–µ 100% parity –º–µ–∂–¥—É Research –∏ Production

---

## –§–∏–ª–æ—Å–æ—Ñ–∏—è

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   RESEARCH         ‚îÇ         ‚îÇ   PRODUCTION       ‚îÇ
‚îÇ   (Jupyter +       ‚îÇ         ‚îÇ   (Freqtrade)      ‚îÇ
‚îÇ    VectorBT)       ‚îÇ         ‚îÇ                    ‚îÇ
‚îÇ                    ‚îÇ         ‚îÇ                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ         ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Backtests   ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ Live Trading ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ         ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ          ‚îÇ         ‚îÇ         ‚îÇ          ‚îÇ         ‚îÇ
‚îÇ          ‚ñº         ‚îÇ         ‚îÇ          ‚ñº         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ         ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   Signals    ‚îÇ‚óÑ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚ñ∫‚îÇ   Signals    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   Library    ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ   Library    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ  SAME   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                    ‚îÇ  CODE!  ‚îÇ                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**–ö–ª—é—á–µ–≤–æ–π –ø—Ä–∏–Ω—Ü–∏–ø**: Code Once, Use Everywhere

---

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞

```
src/
‚îú‚îÄ‚îÄ __init__.py
‚îÇ
‚îú‚îÄ‚îÄ signals/                   # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ indicators.py         # Core: IndicatorLibrary, SignalGenerator
‚îÇ
‚îú‚îÄ‚îÄ risk/                      # Risk management
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ correlation.py        # CorrelationManager, DrawdownMonitor
‚îÇ
‚îî‚îÄ‚îÄ ml_inference/             # ML inference (future)
    ‚îî‚îÄ‚îÄ __init__.py
```

---

## –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

### –í Research (Jupyter):

```python
import sys
sys.path.insert(0, '../src')

from signals.indicators import SignalGenerator
import vectorbt as vbt

# –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
data = vbt.BinanceData.download(...)

# –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤ (–ò–î–ï–ù–¢–ò–ß–ù–û production!)
signal_gen = SignalGenerator()
df = signal_gen.populate_all_indicators(data.get())

entries = signal_gen.generate_entry_signal(df)
exits = signal_gen.generate_exit_signal(df)

# –ë—ç–∫—Ç–µ—Å—Ç
portfolio = vbt.Portfolio.from_signals(
    data.close,
    entries,
    exits,
    fees=0.001
)

print(portfolio.stats())
```

### –í Production (Freqtrade):

```python
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parents[2] / 'src'))

from freqtrade.strategy import IStrategy
from signals.indicators import SignalGenerator

class MyStrategy(IStrategy):
    def __init__(self, config):
        super().__init__(config)
        self.signal_generator = SignalGenerator()

    def populate_indicators(self, dataframe, metadata):
        # –ò–î–ï–ù–¢–ò–ß–ù–û research!
        return self.signal_generator.populate_all_indicators(dataframe)

    def populate_entry_trend(self, dataframe, metadata):
        dataframe['enter_long'] = self.signal_generator.generate_entry_signal(
            dataframe
        )
        return dataframe
```

---

## –ú–æ–¥—É–ª–∏

### signals/indicators.py

**Classes**:
- `IndicatorLibrary`: Pure functions –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
- `SignalGenerator`: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è entry/exit —Å–∏–≥–Ω–∞–ª–æ–≤

**–ú–µ—Ç–æ–¥—ã**:

```python
# Trend indicators
calculate_ema_trio(close, fast=50, medium=100, slow=200)
calculate_adx(high, low, close, period=14)

# Oscillators
calculate_rsi(close, period=14)
calculate_stochastic(high, low, close)
calculate_macd(close, fast=12, slow=26, signal=9)

# Volatility
calculate_bollinger_bands(close, period=20)
calculate_atr(high, low, close, period=14)

# Custom
calculate_trend_score(close, ema_fast, ema_medium, ema_slow)
```

**Signal Generation**:
```python
signal_gen = SignalGenerator()

# –í—Å–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
df = signal_gen.populate_all_indicators(dataframe)

# Entry —Å–∏–≥–Ω–∞–ª—ã
entries = signal_gen.generate_entry_signal(df)

# Exit —Å–∏–≥–Ω–∞–ª—ã
exits = signal_gen.generate_exit_signal(df)
```

---

### risk/correlation.py

**Classes**:
- `CorrelationManager`: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–µ–π –ø–æ—Ä—Ç—Ñ–µ–ª—è
- `DrawdownMonitor`: Circuit breaker –¥–ª—è max drawdown

**Usage**:

```python
from risk.correlation import CorrelationManager, DrawdownMonitor

# Correlation manager
manager = CorrelationManager(
    correlation_window=24,
    max_correlation=0.7,
    max_portfolio_heat=0.15
)

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–¥ –≤—Ö–æ–¥–æ–º
allowed = manager.check_entry_correlation(
    new_pair='ETH/USDT',
    new_pair_data=eth_data,
    open_positions=open_trades,
    all_pairs_data=all_data
)

if not allowed:
    print("‚ùå Entry blocked: high correlation")

# Drawdown monitor
monitor = DrawdownMonitor(
    max_drawdown=0.15,
    stop_duration_minutes=240
)

# –ü—Ä–æ–≤–µ—Ä–∫–∞
trading_allowed = monitor.check_drawdown(
    current_balance=990,
    peak_balance=1000
)
```

---

## Testing

### Unit Tests

```bash
# –¢–µ—Å—Ç—ã shared library
pytest tests/test_signals/ -v

# –¢–µ—Å—Ç—ã parity
pytest tests/test_parity.py -v
```

### Test Example

```python
# tests/test_signals/test_indicators.py

def test_indicator_library():
    from signals.indicators import IndicatorLibrary

    lib = IndicatorLibrary()

    # Test RSI
    rsi = lib.calculate_rsi(sample_close_prices)
    assert (rsi >= 0).all()
    assert (rsi <= 100).all()

def test_signal_generator():
    from signals.indicators import SignalGenerator

    signal_gen = SignalGenerator()

    # Test indicators
    df = signal_gen.populate_all_indicators(sample_dataframe)
    assert 'rsi' in df.columns
    assert 'ema_50' in df.columns

    # Test signals
    entries = signal_gen.generate_entry_signal(df)
    assert entries.isin([0, 1]).all()  # Binary signals
```

---

## Development Guidelines

### 1. Pure Functions

```python
# ‚úÖ Good: Pure function
def calculate_rsi(close: pd.Series, period: int = 14) -> pd.Series:
    """No side effects, testable."""
    return ta.RSI(close, timeperiod=period)

# ‚ùå Bad: Side effects
def calculate_rsi(self, dataframe):
    """Modifies dataframe directly."""
    dataframe['rsi'] = ta.RSI(dataframe['close'])
    self.last_rsi = dataframe['rsi'].iloc[-1]  # Side effect!
```

### 2. Type Hints

```python
# ‚úÖ Always use type hints
def calculate_correlation(
    pair1_data: pd.DataFrame,
    pair2_data: pd.DataFrame,
    method: str = 'pearson'
) -> float:
    ...
```

### 3. Documentation

```python
def calculate_ema_trio(...) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """
    Calculate EMA trio for trend detection.

    Args:
        close: Close prices
        fast: Fast EMA period (default: 50)
        medium: Medium EMA period (default: 100)
        slow: Slow EMA period (default: 200)

    Returns:
        Tuple of (ema_fast, ema_medium, ema_slow)

    Example:
        >>> ema_50, ema_100, ema_200 = calculate_ema_trio(df['close'])
    """
```

### 4. Error Handling

```python
# ‚úÖ Always handle errors gracefully
def calculate_correlation(...) -> float:
    try:
        return returns1.corr(returns2)
    except Exception as e:
        logger.warning(f"Correlation calc failed: {e}")
        return 0.0  # Safe fallback
```

---

## Adding New Indicators

### Step 1: Add to IndicatorLibrary

```python
# src/signals/indicators.py

class IndicatorLibrary:
    @staticmethod
    def calculate_my_indicator(
        close: pd.Series,
        param1: int = 14
    ) -> pd.Series:
        """
        Calculate my custom indicator.

        Args:
            close: Close prices
            param1: Parameter description

        Returns:
            Indicator series
        """
        # Calculation
        return result
```

### Step 2: Add to SignalGenerator

```python
# src/signals/indicators.py

class SignalGenerator:
    def populate_all_indicators(self, dataframe: pd.DataFrame) -> pd.DataFrame:
        # ...
        # Add your indicator
        dataframe['my_indicator'] = self.indicators.calculate_my_indicator(
            dataframe['close'],
            param1=14
        )
        return dataframe
```

### Step 3: Test

```python
# tests/test_signals/test_my_indicator.py

def test_my_indicator():
    from signals.indicators import IndicatorLibrary

    lib = IndicatorLibrary()
    result = lib.calculate_my_indicator(sample_close)

    # Assertions
    assert len(result) == len(sample_close)
    assert not result.isna().all()
```

---

## Roadmap

### Phase 1: ‚úÖ DONE
- Core indicator library
- Signal generation
- Correlation management
- Drawdown monitoring

### Phase 2: üöß IN PROGRESS
- ML inference service (async)
- Redis integration
- WebSocket data streaming

### Phase 3: üìã PLANNED
- Multi-timeframe analysis
- Portfolio optimization
- Advanced risk models
- A/B testing framework

---

## Best Practices

### ‚úÖ DO:

1. **Write pure functions**
2. **Add type hints to everything**
3. **Write tests for all functions**
4. **Document with docstrings**
5. **Handle errors gracefully**
6. **Use logging for important events**

### ‚ùå DON'T:

1. **Don't modify input dataframes in-place**
2. **Don't use global state**
3. **Don't hardcode values**
4. **Don't skip error handling**
5. **Don't commit without tests**

---

## Support

- **Issues**: [GitHub Issues](https://github.com/kandibobe/hft-algotrade-bot/issues)
- **Docs**: [Main README](../README.md)
- **Testing**: [docs/TESTING_GUIDE.md](../docs/TESTING_GUIDE.md)

---

üèõÔ∏è **Stoic Citadel** - Shared library for shared success.
