# Детальный план рефакторинга Stoic Citadel

## Обзор проекта
**Stoic Citadel** - профессиональный MFT (Medium-Frequency Trading) алгоритмический торговый бот с поддержкой ML-инференса, WebSocket стриминга и продвинутого управления ордерами.

## Ключевые проблемы, выявленные при аудите

### 1. Архитектурные проблемы
- **Сильная связность**: Компоненты тесно связаны через прямые импорты
- **Отсутствие DI**: Нет dependency injection, сложно тестировать
- **Дублирование кода**: Обработка разных бирж дублируется в WebSocket модуле
- **Глобальное состояние**: Использование глобальных переменных и синглтонов

### 2. Производительность
- **Redis как bottleneck**: Одна очередь Redis для всех ML запросов
- **Нет backpressure**: WebSocket может переполнить очередь сообщений
- **Неэффективное кэширование**: Простое in-memory кэширование без TTL стратегий

### 3. Тестируемость
- **Зависимость от внешних сервисов**: Redis, WebSocket, биржи
- **Сложное мокирование**: Особенно для асинхронного кода
- **Низкое покрытие тестами**: Критические компоненты недостаточно покрыты

### 4. Безопасность и надежность
- **Нет валидации входных данных**: Особенно в ML сервисе
- **Неполная обработка ошибок**: Многие исключения не обрабатываются
- **Нет rate limiting**: WebSocket может быть забанен биржей

### 5. Масштабируемость
- **Статические конфигурации**: Нет динамической конфигурации
- **Нет горизонтального масштабирования**: Все компоненты запускаются в одном процессе
- **Нет балансировки нагрузки**: Особенно для ML воркеров

---

## Атомарные задачи для рефакторинга

### Фаза 1: Архитектурные улучшения (2 недели)

#### Задача 1.1: Внедрение Dependency Injection
**Цель**: Уменьшить связность и улучшить тестируемость
**Сложность**: Средняя
**Файлы для изменения**:
- `src/order_manager/order_executor.py`
- `src/ml/inference_service.py`
- `src/websocket/data_stream.py`

**Конкретные шаги**:
1. Создать `src/core/di.py` с контейнером зависимостей
2. Заменить прямые инстанцирования на DI
3. Обновить тесты для использования DI

#### Задача 1.2: Рефакторинг обработки бирж в WebSocket
**Цель**: Устранить дублирование кода
**Сложность**: Низкая
**Файлы для изменения**:
- `src/websocket/data_stream.py`

**Конкретные шаги**:
1. Создать абстрактный класс `ExchangeHandler`
2. Реализовать `BinanceHandler`, `BybitHandler`, etc.
3. Использовать стратегию (Strategy pattern) для выбора обработчика

#### Задача 1.3: Выделение общих утилит
**Цель**: Устранить дублирование в утилитарных функциях
**Сложность**: Низкая
**Файлы для изменения**:
- `src/utils/__init__.py`
- Все модули с дублирующимся кодом

**Конкретные шаги**:
1. Проанализировать дублирующийся код
2. Создать `src/utils/common.py`
3. Перенести общие функции

### Фаза 2: Улучшение производительности (1.5 недели)

#### Задача 2.1: Оптимизация Redis использования
**Цель**: Устранить bottleneck в ML сервисе
**Сложность**: Высокая
**Файлы для изменения**:
- `src/ml/inference_service.py`
- `src/ml/redis_client.py`

**Конкретные шаги**:
1. Внедрить sharding для Redis очередей
2. Добавить мониторинг очередей
3. Реализовать приоритетные очереди

#### Задача 2.2: Реализация backpressure для WebSocket
**Цель**: Предотвратить переполнение очереди
**Сложность**: Средняя
**Файлы для изменения**:
- `src/websocket/data_stream.py`

**Конкретные шаги**:
1. Добавить динамическое регулирование скорости
2. Реализовать механизм backpressure
3. Добавить метрики для мониторинга

#### Задача 2.3: Улучшение кэширования
**Цель**: Увеличить hit rate кэша
**Сложность**: Средняя
**Файлы для изменения**:
- `src/ml/inference_service.py`

**Конкретные шаги**:
1. Внедрить LRU кэш с TTL
2. Добавить стратегии инвалидации
3. Добавить метрики кэширования

### Фаза 3: Улучшение тестируемости (1 неделя)

#### Задача 3.1: Создание моков для внешних сервисов
**Цель**: Упростить unit тестирование
**Сложность**: Низкая
**Файлы для изменения**:
- `tests/mocks/__init__.py`

**Конкретные шаги**:
1. Создать `RedisMock`, `WebSocketMock`, `ExchangeAPIMock`
2. Интегрировать моки в существующие тесты
3. Обновить документацию по тестированию

#### Задача 3.2: Увеличение покрытия тестами
**Цель**: Достичь 80% покрытия для критических компонентов
**Сложность**: Средняя
**Файлы для изменения**:
- Все файлы в `tests/`

**Конкретные шаги**:
1. Проанализировать текущее покрытие
2. Написать тесты для `order_executor.py`
3. Написать тесты для `inference_service.py`
4. Написать тесты для `data_stream.py`

#### Задача 3.3: Интеграционные тесты
**Цель**: Проверка взаимодействия компонентов
**Сложность**: Высокая
**Файлы для изменения**:
- `tests/test_integration/`

**Конкретные шаги**:
1. Создать тестовый сценарий полного цикла торговли
2. Реализовать тесты с использованием Docker Compose
3. Добавить performance тесты

### Фаза 4: Безопасность и надежность (1 неделя)

#### Задача 4.1: Валидация входных данных
**Цель**: Предотвратить injection attacks и ошибки
**Сложность**: Низкая
**Файлы для изменения**:
- `src/ml/inference_service.py`
- `src/order_manager/order_types.py`

**Конкретные шаги**:
1. Добавить Pydantic модели для валидации
2. Валидировать все внешние данные
3. Добавить санитизацию входных данных

#### Задача 4.2: Улучшение обработки ошибок
**Цель**: Гарантировать graceful degradation
**Сложность**: Средняя
**Файлы для изменения**:
- Все критические модули

**Конкретные шаги**:
1. Добавить retry логику с exponential backoff
2. Реализовать circuit breaker pattern
3. Добавить comprehensive logging

#### Задача 4.3: Rate limiting для WebSocket
**Цель**: Предотвратить бан от бирж
**Сложность**: Средняя
**Файлы для изменения**:
- `src/websocket/data_stream.py`

**Конкретные шаги**:
1. Реализовать token bucket алгоритм
2. Добавить конфигурацию rate limits
3. Добавить мониторинг нарушений лимитов

### Фаза 5: Масштабируемость (1.5 недели)

#### Задача 5.1: Динамическая конфигурация
**Цель**: Поддержка hot reload конфигурации
**Сложность**: Средняя
**Файлы для изменения**:
- `src/config/validated_config.py`
- Все модули, использующие конфигурацию

**Конкретные шаги**:
1. Внедрить конфигурацию из environment variables
2. Добавить поддержку конфигурационных файлов
3. Реализовать hot reload

#### Задача 5.2: Поддержка горизонтального масштабирования
**Цель**: Возможность запуска multiple instances
**Сложность**: Высокая
**Файлы для изменения**:
- `src/ml/inference_service.py`
- `src/websocket/data_stream.py`

**Конкретные шаги**:
1. Добавить идентификаторы инстансов
2. Реализовать распределенные блокировки
3. Добавить health checks и load balancing

#### Задача 5.3: Мониторинг и метрики
**Цель**: Визуализация производительности системы
**Сложность**: Средняя
**Файлы для изменения**:
- `src/monitoring/trading_metrics.py`
- Все критические модули

**Конкретные шаги**:
1. Интегрировать Prometheus метрики
2. Добавить Grafana дашборды
3. Реализовать алертинг

---

## Приоритетность задач

### Высокий приоритет (неделя 1-2)
1. **Задача 1.1**: Dependency Injection (критично для тестируемости)
2. **Задача 4.1**: Валидация входных данных (безопасность)
3. **Задача 3.1**: Моки для тестирования (ускорит разработку)

### Средний приоритет (неделя 3-4)
4. **Задача 1.2**: Рефакторинг WebSocket (устранит дублирование)
5. **Задача 2.2**: Backpressure для WebSocket (стабильность)
6. **Задача 4.2**: Улучшение обработки ошибок (надежность)

### Низкий приоритет (неделя 5-6)
7. **Задача 2.1**: Оптимизация Redis (производительность)
8. **Задача 5.2**: Горизонтальное масштабирование (масштабируемость)
9. **Задача 5.3**: Мониторинг (observability)

---

## Ожидаемые результаты

### После Фазы 1 (2 недели)
- Уменьшение связности на 40%
- Увеличение покрытия тестами до 60%
- Упрощение добавления новых бирж

### После Фазы 2-3 (2.5 недели)
- Увеличение производительности на 30%
- Достижение 80% покрытия тестами
- Улучшение стабильности системы

### После Фазы 4-5 (2.5 недели)
- Zero-downtime deployments
- Поддержка горизонтального масштабирования
- Полная observability системы

---

## Риски и митигации

### Риск 1: Нарушение обратной совместимости
**Митигация**: 
- Сохранить старые интерфейсы с deprecation warnings
- Поэтапный rollout изменений
- Comprehensive testing

### Риск 2: Увеличение сложности кода
**Митигация**:
- Детальная документация
- Code reviews
- Обучение команды

### Риск 3: Производительность новых абстракций
**Митигация**:
- Performance testing на каждом этапе
- Профилирование кода
- Оптимизация критических путей

---

## Метрики успеха

1. **Coverage**: 80%+ для критических компонентов
2. **Performance**: 30% улучшение latency
3. **Reliability**: 99.9% uptime в тестовой среде
4. **Maintainability**: Уменьшение cyclomatic complexity на 25%
5. **Security**: Zero critical vulnerabilities

---

## Следующие шаги

1. **Неделя 1**: Начать с Задачи 1.1 (Dependency Injection)
2. **Неделя 2**: Параллельно работать над Задачами 4.1 и 3.1
3. **Неделя 3**: Перейти к Фазе 2 (производительность)
4. **Неделя 4**: Завершить Фазу 3 (тестирование)
5. **Неделя 5-6**: Реализовать Фазы 4-5

Каждая задача самодостаточна и может быть выполнена независимо, что соответствует требованию "атомарных задач для скармливания другой нейросети по одной".
